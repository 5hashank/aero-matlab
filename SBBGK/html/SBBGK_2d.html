
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SBBGK_2d</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-02-14"><meta name="DC.source" content="SBBGK_2d.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">2D Semi-classical Boltzmann-BGK Equation</a></li><li><a href="#2">Simulation Parameters</a></li><li><a href="#3">Space Discretization</a></li><li><a href="#4">Define a ID name for results file</a></li><li><a href="#5">Open a Files to store the Results</a></li><li><a href="#6">Velocity Discretization:</a></li><li><a href="#7">Velocity-Space Grid:</a></li><li><a href="#8">Initial Conditions</a></li><li><a href="#9">Marching Scheme</a></li><li><a href="#10">Write Results</a></li></ul></div><h2>2D Semi-classical Boltzmann-BGK Equation<a name="1"></a></h2><p>Numerical solution of the Boltzmann-BGK Equation to recover Euler macroscopic continuum solution. Coded by Manuel Diaz 2013.02.14</p><p>Semi-classical Boltzmann-BGK Transport Equation:</p><p><img src="SBBGK_2d_eq49006.png" alt="$$\frac{\partial f}{\partial t}+\vec F\cdot \nabla_p f + \vec v&#xA;\cdot\nabla_{\vec x} f =\widehat{\Omega } (f) = - \frac{f-f^{eq}}{\tau}$$"></p><pre class="codeinput">clc;  clear <span class="string">all</span>;  close <span class="string">all</span>;
</pre><h2>Simulation Parameters<a name="2"></a></h2><pre class="codeinput">    name   =<span class="string">'SBBGK2d'</span>;  <span class="comment">% Simulation Name</span>
    CFL    = 50/100;    <span class="comment">% CFL condition</span>
    r_time = 1/10000;   <span class="comment">% Relaxation time</span>
    tEnd   = 0.00;      <span class="comment">% Out time</span>
    theta  = 0;         <span class="comment">% {-1} BE, {0} MB, {1} FD.</span>
   fmodel  = 1;         <span class="comment">% {1} UU. model, {2} ES model.</span>
    quad   = 2;         <span class="comment">% {1} NC , {2} GH</span>
    method = 1;         <span class="comment">% {1} TVD, {2} WENO3, {3} WENO5</span>
   IC_case = 5;         <span class="comment">% Reimann cases: 1~17</span>
 plot_figs = 0;         <span class="comment">% 0: no, 1: yes please!</span>
 write_ans = 0;         <span class="comment">% 0: no, 1: yes please!</span>
 <span class="comment">% Using DG</span>
    P_deg  = 0;         <span class="comment">% Polinomial Degree</span>
    Pp 	   = P_deg+1;   <span class="comment">% Polinomials Points</span>
<span class="comment">% Using RK integration time step</span>
RK_stages   = 4;        <span class="comment">% Number of RK stages</span>
</pre><h2>Space Discretization<a name="3"></a></h2><pre class="codeinput">nx = 80; ny = 80;
[X,dx,Y,dy] = grid2d(0,1,nx,0,1,ny);
[x,y] = meshgrid(X,Y);
</pre><h2>Define a ID name for results file<a name="4"></a></h2><pre class="codeinput">[ID, IDn] = ID_name(name,theta,nx,P_deg,RK_stages,r_time,IC_case);
</pre><h2>Open a Files to store the Results<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> write_ans == 1
    file = fopen(IDn,<span class="string">'w'</span>);
    <span class="comment">% 'file' gets the handel for the file "case.plt".</span>
    <span class="comment">% 'w' specifies that it will be written.</span>
    <span class="comment">% similarly 'r' is for reading and 'a' for appending.</span>
    fprintf(file, <span class="string">'TITLE = "%s"\n'</span>,ID);
    fprintf(file, <span class="string">'VARIABLES = "x" "y" "n" "E" "p" "t" "z"\n'</span>);
<span class="keyword">end</span>
</pre><h2>Velocity Discretization:<a name="6"></a></h2><pre class="codeinput"><span class="keyword">switch</span> quad

    <span class="keyword">case</span>{1} <span class="comment">% Newton Cotes Quadrature:</span>
    V  = [-10,10];  <span class="comment">% range: a to b</span>
    nv = 50;        <span class="comment">% nodes desired (may not the actual value)</span>
    [v,w,k] = cotes_xw(V(1),V(2),nv,5); <span class="comment">% cotes Degree 5</span>

    <span class="keyword">case</span>{2} <span class="comment">% Gauss Hermite Quadrature:</span>
    nv = 20;        <span class="comment">% nodes desired (the actual value)</span>
    [v,w] = GaussHermite(nv); <span class="comment">% for integrating range: -inf to inf</span>
     k = 1;         <span class="comment">% quadrature constant.</span>
     w = w.*exp(v.^2);

    <span class="keyword">otherwise</span>
        error(<span class="string">'Order must be between 1 and 2'</span>);
<span class="keyword">end</span>
</pre><h2>Velocity-Space Grid:<a name="7"></a></h2><p>The actual nv value will be computed using 'length' vector function:</p><pre class="codeinput">nv = length(v);

<span class="comment">% Using Discrete Ordinate Method (Replicating Data)</span>
    [vx,vy] = meshgrid(v,v');       [wx,wy] = meshgrid(w,w');
    vx = repmat(vx,[1,1,ny,nx]);    wx = repmat(wx,[1,1,ny,nx]);
    vy = repmat(vy,[1,1,ny,nx]);    wy = repmat(wy,[1,1,ny,nx]);
</pre><h2>Initial Conditions<a name="8"></a></h2><p>Load Macroscopic Velocity, Temperature and Fugacity</p><pre class="codeinput">    [z0,ux0,uy0,t0] = SSBGK_IC2d(x,y,IC_case);

<span class="comment">% Using Discrete Ordinate Method: (Replicating Data for easyer arrays Ops)</span>
    z = zeros(nv,nv);   ux = zeros(nv,nv);
    uy = zeros(nv,nv);   t = zeros(nv,nv);

<span class="keyword">for</span> j = 1:ny
     <span class="keyword">for</span> i = 1:nx
     z(:,:,j,i) = z0(j,i)*ones(nv,nv);  ux(:,:,j,i) = ux0(j,i)*ones(nv,nv);
     uy(:,:,j,i) = uy0(j,i)*ones(nv,nv);  t(:,:,j,i) = t0(j,i)*ones(nv,nv);
     <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Compute distribution IC of our mesoscopic method by assuming the equilibrium</span>
<span class="comment">% state of the macroscopic IC. Using the semiclassical Equilibrium</span>
<span class="comment">% distribuition function:</span>
    f0 = f_equilibrium_2d(z,ux,uy,t,vx,vy,theta);

<span class="comment">% Plot Probability Distribution Function, f, for an expecific point in space:</span>
<span class="keyword">if</span> plot_figs == 1
    figure(1)
    i = 2; j = 2;
    zz = f0(:,:,j,i);
    surf(zz); grid <span class="string">on</span>;
    xlabel(<span class="string">'v1 - Velocity Space in x'</span>);
    ylabel(<span class="string">'v2 - Velocity Space in y'</span>);
	zlabel(<span class="string">'f - Probability'</span>);
	clear <span class="string">zz</span> <span class="string">i</span> <span class="string">j</span>
<span class="keyword">end</span>

<span class="comment">% Compute Initial Macroscopic Momemts:</span>
    [rho,rhoux,rhouy,E] = macromoments2d(k,wx,wy,f0,vx,vy);
    [~,~,~,~,p] = macroproperties2d(rho,rhoux,rhouy,E,nx,ny,theta);
</pre><h2>Marching Scheme<a name="9"></a></h2><p>First we need to define how big is our time step. Due to the discrete ordinate method the problem is similar to evolve the same problem for every mesoscopic velocity.</p><pre class="codeinput">dt = min(dx,dy)*CFL/max(v);
dtdx = dt/dx;  <span class="comment">% precomputed to save someflops</span>
dtdy = dt/dy;  <span class="comment">% precomputed to save someflops</span>

<span class="comment">% time domain discretization</span>
time = 0:dt:tEnd;

<span class="comment">% By negleting any force field acting over our domian, the classic</span>
<span class="comment">% transport Boltzmann equation will resemble to a pure advection equation.</span>
<span class="comment">% Thus we use WENO, TVD, DG or CPR can be used to compute evolution of the</span>
<span class="comment">% information inside the domain:</span>
tic
<span class="keyword">switch</span> method

    <span class="keyword">case</span>{1} <span class="comment">% TVD 0(h^2)</span>
        <span class="comment">% Using Discrete Ordinate Method (Discrete and constant velocity</span>
        <span class="comment">% values in phase-space domain)</span>
        a = vx(:,:,1,1);
        b = vy(:,:,1,1);

        <span class="comment">% Load initial condition</span>
        f = f0;

        <span class="comment">% Initialize vector variables</span>
        u_next = zeros(ny,nx);
        u_eq = zeros(ny,nx);
        u = zeros(ny,nx);

        <span class="keyword">for</span> tsteps = time
            <span class="comment">% Plot and redraw figures every time step for visualization</span>
            <span class="keyword">if</span> plot_figs == 1
            <span class="comment">% Plot Macroscopic variables</span>
            figure(2)
            subplot(2,3,1); nn(:,:) = rho(:,:); h2 = surf(nn); title(<span class="string">'Density'</span>)
            subplot(2,3,2); pp(:,:) = p(:,:); h4 = surf(pp); title(<span class="string">'Pressure'</span>)
            subplot(2,3,3); tt(:,:) = t(1,1,:,:); h3 = surf(tt); title(<span class="string">'Temperature'</span>)
            subplot(2,3,4); zz(:,:) = z(1,1,:,:); h1 = surf(zz); title(<span class="string">'Fugacity'</span>)
            subplot(2,3,5); EE(:,:) = E(:,:); h5 = surf(EE); title(<span class="string">'Energy'</span>)
            <span class="keyword">end</span>
            <span class="comment">% Write Results</span>
            <span class="keyword">if</span> write_ans == 1 &amp;&amp; (mod(tsteps,10*dt) == 0 || tsteps == time(end))
                fprintf(file, <span class="string">'ZONE T = "time %0.4f"\n'</span>, tsteps);
                fprintf(file, <span class="string">'I = %d, J = %d, K = 1, F = POINT\n\n'</span>,nx,ny);
                <span class="keyword">for</span> j = 1:ny
                <span class="keyword">for</span> i = 1:nx
                    fprintf(file, <span class="string">'%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n'</span>, <span class="keyword">...</span>
                        x(j,i),y(j,i),rho(j,i),E(j,i),p(j,i),t(1,1,j,i),z(1,1,j,i));
                <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Compute Equilibrium Distribution for the current time step</span>
            f_eq = f_equilibrium_2d(z,ux,uy,t,vx,vy,theta);

            <span class="comment">% (this part can, and should be done in parallel!)</span>
            <span class="keyword">for</span>  j = 1:nv
                <span class="keyword">for</span> i = 1:nv
                <span class="comment">% Load our physical domain</span>
                u_eq(:,:) = f_eq(j,i,:,:);
                u(:,:) = f(j,i,:,:);

                <span class="comment">% Compute Theta (smoothness coeficients)</span>
                [rx,ry] = theta2d(u,a(j,i),b(j,i));

                <span class="comment">% Compute flux Limiter</span>
                [phix,phiy] = fluxlimiter2d(rx,ry,1); <span class="comment">% using limiter = 1</span>

                <span class="comment">% Compute TVD Fluxes:</span>
                [F_l,F_r,G_l,G_r] = TVDflux2d(u,a(j,i),b(j,i),dtdx,dtdy,phix,phiy);

                <span class="comment">% Compute next time step</span>
                u_next = u - dtdx*(F_r - F_l) - dtdy*(G_r - G_l) <span class="keyword">...</span>
                    - (dt/r_time)*(u-u_eq);

                <span class="comment">% BCs</span>
                u_next(:,1)  = u_next(:,2);
                u_next(:,nx) = u_next(:,nx-1);
                u_next(1,:)  = u_next(2,:);
                u_next(ny,:) = u_next(ny-1,:);

                <span class="comment">% UPDATE info</span>
                u = u_next;

                <span class="comment">% Going back to f</span>
                f(j,i,:,:) = u(:,:);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Compute macroscopic moments</span>
            [rho,rhoux,rhouy,E] = macromoments2d(k,wx,wy,f,vx,vy);

            <span class="comment">% UPDATE macroscopic properties</span>
            <span class="comment">% (here lies a parallel computing challenge)</span>
            [z1,ux1,uy1,t1,p1] = macroproperties2d(rho,rhoux,rhouy,E,nx,ny,theta);

            <span class="comment">% Using Discrete Ordinate Method: (Replicating data for easier arrays Ops)</span>
            <span class="keyword">for</span> j = 1:ny
                <span class="keyword">for</span> i = 1:nx
                z(:,:,j,i)  = z1(j,i)*ones(nv,nv);  ux(:,:,j,i) = ux1(j,i)*ones(nv,nv);
                uy(:,:,j,i) = uy1(j,i)*ones(nv,nv); t(:,:,j,i) = t1(j,i)*ones(nv,nv);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Update Figures</span>
            drawnow
        <span class="keyword">end</span>

    <span class="keyword">case</span>{2} <span class="comment">% WENO(r=2)3, O(h^5)</span>
            <span class="comment">% under construction ...</span>
    <span class="keyword">otherwise</span>
        error(<span class="string">'Order must be between 1 and 2'</span>);
<span class="keyword">end</span>
toc
</pre><pre class="codeoutput">Elapsed time is 31.384261 seconds.
</pre><h2>Write Results<a name="10"></a></h2><pre class="codeinput">fprintf(<span class="string">'Simulation has been completed succesfully!\n'</span>)
<span class="keyword">if</span> write_ans == 1
    fclose(file);
    fprintf(<span class="string">'All Results have been saved!\n'</span>)
<span class="keyword">end</span>

<span class="keyword">if</span> plot_figs ~= 1
    <span class="comment">% Plot Macroscopic variables</span>
    figure(2)
    subplot(2,3,1); nn(:,:) = rho(:,:); h2 = surface(nn); title(<span class="string">'Density'</span>)
    subplot(2,3,2); pp(:,:) = p(:,:); h4 = surface(pp); title(<span class="string">'Pressure'</span>)
    subplot(2,3,3); tt(:,:) = t(1,1,:,:); h3 = surface(tt); title(<span class="string">'Temperature'</span>)
    subplot(2,3,4); zz(:,:) = z(1,1,:,:); h1 = surface(zz); title(<span class="string">'Fugacity'</span>)
    subplot(2,3,5); EE(:,:) = E(:,:); h5 = surface(EE); title(<span class="string">'Energy'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Simulation has been completed succesfully!
</pre><img vspace="5" hspace="5" src="SBBGK_2d_01.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% 2D Semi-classical Boltzmann-BGK Equation
% Numerical solution of the Boltzmann-BGK Equation to recover Euler macroscopic
% continuum solution. Coded by Manuel Diaz 2013.02.14
%
% Semi-classical Boltzmann-BGK Transport Equation:
%
% $$\frac{\partial f}{\partial t}+\vec F\cdot \nabla_p f + \vec v
% \cdot\nabla_{\vec x} f =\widehat{\Omega } (f) = - \frac{f-f^{eq}}{\tau}$$
%
clc;  clear all;  close all;

%% Simulation Parameters
    name   ='SBBGK2d';  % Simulation Name
    CFL    = 50/100;    % CFL condition
    r_time = 1/10000;   % Relaxation time
    tEnd   = 0.00;      % Out time
    theta  = 0;         % {-1} BE, {0} MB, {1} FD.
   fmodel  = 1;         % {1} UU. model, {2} ES model.
    quad   = 2;         % {1} NC , {2} GH
    method = 1;         % {1} TVD, {2} WENO3, {3} WENO5
   IC_case = 5;         % Reimann cases: 1~17
 plot_figs = 0;         % 0: no, 1: yes please!
 write_ans = 0;         % 0: no, 1: yes please!
 % Using DG
    P_deg  = 0;         % Polinomial Degree
    Pp 	   = P_deg+1;   % Polinomials Points
% Using RK integration time step
RK_stages   = 4;        % Number of RK stages

%% Space Discretization
nx = 80; ny = 80;
[X,dx,Y,dy] = grid2d(0,1,nx,0,1,ny);
[x,y] = meshgrid(X,Y);

%% Define a ID name for results file
[ID, IDn] = ID_name(name,theta,nx,P_deg,RK_stages,r_time,IC_case);

%% Open a Files to store the Results
if write_ans == 1
    file = fopen(IDn,'w');
    % 'file' gets the handel for the file "case.plt".
    % 'w' specifies that it will be written.
    % similarly 'r' is for reading and 'a' for appending.
    fprintf(file, 'TITLE = "%s"\n',ID);
    fprintf(file, 'VARIABLES = "x" "y" "n" "E" "p" "t" "z"\n');
end

%% Velocity Discretization:
switch quad

    case{1} % Newton Cotes Quadrature:
    V  = [-10,10];  % range: a to b
    nv = 50;        % nodes desired (may not the actual value)
    [v,w,k] = cotes_xw(V(1),V(2),nv,5); % cotes Degree 5

    case{2} % Gauss Hermite Quadrature:
    nv = 20;        % nodes desired (the actual value)
    [v,w] = GaussHermite(nv); % for integrating range: -inf to inf
     k = 1;         % quadrature constant.
     w = w.*exp(v.^2);
    
    otherwise
        error('Order must be between 1 and 2');
end
%% Velocity-Space Grid:
% The actual nv value will be computed using 'length' vector function:
nv = length(v); 

% Using Discrete Ordinate Method (Replicating Data)
    [vx,vy] = meshgrid(v,v');       [wx,wy] = meshgrid(w,w');
    vx = repmat(vx,[1,1,ny,nx]);    wx = repmat(wx,[1,1,ny,nx]);
    vy = repmat(vy,[1,1,ny,nx]);    wy = repmat(wy,[1,1,ny,nx]);

%% Initial Conditions
% Load Macroscopic Velocity, Temperature and Fugacity
    [z0,ux0,uy0,t0] = SSBGK_IC2d(x,y,IC_case);
    
% Using Discrete Ordinate Method: (Replicating Data for easyer arrays Ops)
    z = zeros(nv,nv);   ux = zeros(nv,nv);
    uy = zeros(nv,nv);   t = zeros(nv,nv);

for j = 1:ny
     for i = 1:nx
     z(:,:,j,i) = z0(j,i)*ones(nv,nv);  ux(:,:,j,i) = ux0(j,i)*ones(nv,nv);
     uy(:,:,j,i) = uy0(j,i)*ones(nv,nv);  t(:,:,j,i) = t0(j,i)*ones(nv,nv);
     end
end

% Compute distribution IC of our mesoscopic method by assuming the equilibrium
% state of the macroscopic IC. Using the semiclassical Equilibrium
% distribuition function:
    f0 = f_equilibrium_2d(z,ux,uy,t,vx,vy,theta);

% Plot Probability Distribution Function, f, for an expecific point in space:
if plot_figs == 1
    figure(1)  
    i = 2; j = 2;
    zz = f0(:,:,j,i);
    surf(zz); grid on;
    xlabel('v1 - Velocity Space in x'); 
    ylabel('v2 - Velocity Space in y');
	zlabel('f - Probability');
	clear zz i j
end
    
% Compute Initial Macroscopic Momemts:
    [rho,rhoux,rhouy,E] = macromoments2d(k,wx,wy,f0,vx,vy);
    [~,~,~,~,p] = macroproperties2d(rho,rhoux,rhouy,E,nx,ny,theta);
    
%% Marching Scheme
% First we need to define how big is our time step. Due to the discrete
% ordinate method the problem is similar to evolve the same problem for
% every mesoscopic velocity.
dt = min(dx,dy)*CFL/max(v); 
dtdx = dt/dx;  % precomputed to save someflops
dtdy = dt/dy;  % precomputed to save someflops

% time domain discretization
time = 0:dt:tEnd;

% By negleting any force field acting over our domian, the classic
% transport Boltzmann equation will resemble to a pure advection equation.
% Thus we use WENO, TVD, DG or CPR can be used to compute evolution of the
% information inside the domain: 
tic
switch method
    
    case{1} % TVD 0(h^2)
        % Using Discrete Ordinate Method (Discrete and constant velocity
        % values in phase-space domain)
        a = vx(:,:,1,1);
        b = vy(:,:,1,1);
        
        % Load initial condition
        f = f0;
                
        % Initialize vector variables
        u_next = zeros(ny,nx);
        u_eq = zeros(ny,nx);
        u = zeros(ny,nx);
        
        for tsteps = time
            % Plot and redraw figures every time step for visualization
            if plot_figs == 1
            % Plot Macroscopic variables
            figure(2)
            subplot(2,3,1); nn(:,:) = rho(:,:); h2 = surf(nn); title('Density')
            subplot(2,3,2); pp(:,:) = p(:,:); h4 = surf(pp); title('Pressure')
            subplot(2,3,3); tt(:,:) = t(1,1,:,:); h3 = surf(tt); title('Temperature')
            subplot(2,3,4); zz(:,:) = z(1,1,:,:); h1 = surf(zz); title('Fugacity')
            subplot(2,3,5); EE(:,:) = E(:,:); h5 = surf(EE); title('Energy')
            end
            % Write Results
            if write_ans == 1 && (mod(tsteps,10*dt) == 0 || tsteps == time(end))
                fprintf(file, 'ZONE T = "time %0.4f"\n', tsteps);
                fprintf(file, 'I = %d, J = %d, K = 1, F = POINT\n\n',nx,ny);
                for j = 1:ny
                for i = 1:nx
                    fprintf(file, '%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n', ...
                        x(j,i),y(j,i),rho(j,i),E(j,i),p(j,i),t(1,1,j,i),z(1,1,j,i));
                end
                end
            end
            
            % Compute Equilibrium Distribution for the current time step
            f_eq = f_equilibrium_2d(z,ux,uy,t,vx,vy,theta);
                                          
            % (this part can, and should be done in parallel!)
            for  j = 1:nv
                for i = 1:nv
                % Load our physical domain
                u_eq(:,:) = f_eq(j,i,:,:);
                u(:,:) = f(j,i,:,:);
                                    
                % Compute Theta (smoothness coeficients)
                [rx,ry] = theta2d(u,a(j,i),b(j,i));

                % Compute flux Limiter 
                [phix,phiy] = fluxlimiter2d(rx,ry,1); % using limiter = 1

                % Compute TVD Fluxes:
                [F_l,F_r,G_l,G_r] = TVDflux2d(u,a(j,i),b(j,i),dtdx,dtdy,phix,phiy);

                % Compute next time step
                u_next = u - dtdx*(F_r - F_l) - dtdy*(G_r - G_l) ...
                    - (dt/r_time)*(u-u_eq);

                % BCs
                u_next(:,1)  = u_next(:,2);
                u_next(:,nx) = u_next(:,nx-1);
                u_next(1,:)  = u_next(2,:);
                u_next(ny,:) = u_next(ny-1,:);

                % UPDATE info
                u = u_next;
                
                % Going back to f
                f(j,i,:,:) = u(:,:);
                end
            end
            
            % Compute macroscopic moments
            [rho,rhoux,rhouy,E] = macromoments2d(k,wx,wy,f,vx,vy);
            
            % UPDATE macroscopic properties 
            % (here lies a parallel computing challenge)
            [z1,ux1,uy1,t1,p1] = macroproperties2d(rho,rhoux,rhouy,E,nx,ny,theta);
            
            % Using Discrete Ordinate Method: (Replicating data for easier arrays Ops)
            for j = 1:ny
                for i = 1:nx
                z(:,:,j,i)  = z1(j,i)*ones(nv,nv);  ux(:,:,j,i) = ux1(j,i)*ones(nv,nv);
                uy(:,:,j,i) = uy1(j,i)*ones(nv,nv); t(:,:,j,i) = t1(j,i)*ones(nv,nv);
                end
            end
            
            % Update Figures
            drawnow
        end
        
    case{2} % WENO(r=2)3, O(h^5) 
            % under construction ...
    otherwise
        error('Order must be between 1 and 2');
end
toc

%% Write Results
fprintf('Simulation has been completed succesfully!\n')
if write_ans == 1
    fclose(file);
    fprintf('All Results have been saved!\n')
end

if plot_figs ~= 1
    % Plot Macroscopic variables
    figure(2)
    subplot(2,3,1); nn(:,:) = rho(:,:); h2 = surface(nn); title('Density')
    subplot(2,3,2); pp(:,:) = p(:,:); h4 = surface(pp); title('Pressure')
    subplot(2,3,3); tt(:,:) = t(1,1,:,:); h3 = surface(tt); title('Temperature')
    subplot(2,3,4); zz(:,:) = z(1,1,:,:); h1 = surface(zz); title('Fugacity')
    subplot(2,3,5); EE(:,:) = E(:,:); h5 = surface(EE); title('Energy')
end
##### SOURCE END #####
--></body></html>