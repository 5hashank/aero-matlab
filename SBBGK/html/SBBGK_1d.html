
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>SBBGK_1d</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-02-14"><meta name="DC.source" content="SBBGK_1d.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">1D Semi-classical Boltzmann-BGK Equation</a></li><li><a href="#2">Simulation Parameters</a></li><li><a href="#3">Space Discretization</a></li><li><a href="#4">Define a ID name for results file</a></li><li><a href="#5">Open a Files to store the Results</a></li><li><a href="#6">Initial Conditions in physical Space</a></li><li><a href="#7">Microscopic Velocity Discretization (using Discrete Ordinate Method)</a></li><li><a href="#8">Velocity-Space Grid:</a></li><li><a href="#9">Applying Discrete Ordinate Method on ICs:</a></li><li><a href="#10">Marching Scheme</a></li><li><a href="#11">Close file with Results</a></li></ul></div><h2>1D Semi-classical Boltzmann-BGK Equation<a name="1"></a></h2><p>Numerical solution of the Boltzmann-BGK Equation to recover Euler macroscopic continuum solution. Coded by Manuel Diaz 2012.10.06</p><p>Semi-classical Boltzmann-BGK Transport Equation:</p><p><img src="SBBGK_1d_eq49006.png" alt="$$\frac{\partial f}{\partial t}+\vec F\cdot \nabla_p f + \vec v&#xA;\cdot\nabla_{\vec x} f =\widehat{\Omega } (f) = - \frac{f-f^{eq}}{\tau}$$"></p><pre class="codeinput">clc;  clear <span class="string">all</span>;  close <span class="string">all</span>;
</pre><h2>Simulation Parameters<a name="2"></a></h2><pre class="codeinput">    name	=<span class="string">'SBBGK1d'</span>; <span class="comment">% Simulation Name</span>
    CFL     = 10/100;   <span class="comment">% CFL condition</span>
    r_time  = 1/10000;  <span class="comment">% Relaxation time</span>
    tEnd  	= 0.05;     <span class="comment">% End time</span>
    theta 	= 0;        <span class="comment">% {-1} BE, {0} MB, {1} FD.</span>
    fmodel  = 1;        <span class="comment">% {1} UU. model, {2} ES model.</span>
    quad   	= 2;        <span class="comment">% {1} NC , {2} GH</span>
    method 	= 2;        <span class="comment">% {1} Upwind, {2} TVD, {3} WENO3, {4} WENO5</span>
    IC_case	= 1;        <span class="comment">% IC: {1}Sod's, {2}LE, {3}RE, {4}DS, {5}SS, {6}Cavitation</span>
  plot_figs = 0;        <span class="comment">% 0: no, 1: yes please!</span>
  write_ans = 1;        <span class="comment">% 0: no, 1: yes please!</span>
<span class="comment">% Using DG</span>
    P_deg	= 0;        <span class="comment">% Polinomial Degree</span>
    Pp      = P_deg+1;  <span class="comment">% Polinomials Points</span>
<span class="comment">% Using RK integration time step</span>
  RK_stages	= 4;        <span class="comment">% Number of RK stages</span>
</pre><h2>Space Discretization<a name="3"></a></h2><pre class="codeinput">nx  = 100;                      <span class="comment">% Desided number of points in our domain</span>
x   = linspace(0,1,nx);         <span class="comment">% Physical domain -x</span>
dx  = max(x(2:end)-x(1:end-1)); <span class="comment">% delta x</span>
</pre><h2>Define a ID name for results file<a name="4"></a></h2><pre class="codeinput">[ID, IDn] = ID_name(name,theta,nx,P_deg,RK_stages,r_time,IC_case);
</pre><h2>Open a Files to store the Results<a name="5"></a></h2><pre class="codeinput"><span class="keyword">if</span> write_ans == 1
    file = fopen(IDn,<span class="string">'w'</span>);
    <span class="comment">% 'file' gets the handel for the file "case.plt".</span>
    <span class="comment">% 'w' specifies that it will be written.</span>
    <span class="comment">% similarly 'r' is for reading and 'a' for appending.</span>
    fprintf(file, <span class="string">'TITLE = "%s"\n'</span>,ID);
    fprintf(file, <span class="string">'VARIABLES = "x" "density" "velocity" "energy" "pressure" "temperature" "fugacity"\n'</span>);
<span class="keyword">end</span>
</pre><h2>Initial Conditions in physical Space<a name="6"></a></h2><p>Load Macroscopic Fugacity [z], Velocity[u] and Temperature[t]</p><pre class="codeinput">    <span class="comment">%[z0,u0,t0,p0,rho0,E0] = SSBGK_IC1d(x,IC_case);</span>
    [z0,u0,t0,p0,rho0,E0] = SSBGK_IC1d(x,IC_case);
</pre><pre class="codeoutput">Case 1: Sods problem 
</pre><h2>Microscopic Velocity Discretization (using Discrete Ordinate Method)<a name="7"></a></h2><p>that is to make coincide discrete values of microscopic velocities with values as the value points for using a quadrature method, so that we can integrate the velocity probability distribution to recover our macroscopics properties.</p><pre class="codeinput"><span class="keyword">switch</span> quad

    <span class="keyword">case</span>{1} <span class="comment">% Newton Cotes Quadrature:</span>
    V  = [-40,40];  <span class="comment">% range: a to b</span>
    nv = 200;       <span class="comment">% nodes desired (may not the actual value)</span>
    [v,w,k] = cotes_xw(V(1),V(2),nv,5); <span class="comment">% Using Netwon Cotes Degree 5</span>

    <span class="keyword">case</span>{2} <span class="comment">% Gauss Hermite Quadrature:</span>
    nv = 80;          <span class="comment">% nodes desired (the actual value)</span>
    [v,w] = GaussHermite(nv); <span class="comment">% for integrating range: -inf to inf</span>
    k = 1;            <span class="comment">% quadrature constant.</span>
    w = w.*exp(v.^2); <span class="comment">% weighting function of the Gauss-Hermite quadrature</span>

    <span class="keyword">otherwise</span>
        error(<span class="string">'Order must be between 1 and 2'</span>);
<span class="keyword">end</span>
</pre><h2>Velocity-Space Grid:<a name="8"></a></h2><p>The actual nv value will be computed using 'length' vector function:</p><pre class="codeinput">    nv = length(v);
<span class="comment">% Using D.O.M.</span>
    v = repmat(v,1,nx);     w = repmat(w,1,nx);
</pre><h2>Applying Discrete Ordinate Method on ICs:<a name="9"></a></h2><pre class="codeinput">[z,ux,t] = apply_DOM(z0,u0,t0,nv);  <span class="comment">% Semi-classical IC</span>
[p,rho,E] = apply_DOM(p0,rho0,E0,nv); <span class="comment">% Classical IC</span>

<span class="comment">% Compute distribution IC of our mesoscopic method by assuming the equilibrium</span>
<span class="comment">% state of the macroscopic IC. Using the semiclassical Equilibrium</span>
<span class="comment">% distribuition function:</span>
<span class="keyword">switch</span> fmodel
    <span class="keyword">case</span>{1} <span class="comment">% U.U.</span>
        f0 = f_equilibrium_1d(z,ux,v,t,theta);
    <span class="keyword">case</span>{2} <span class="comment">% E.S.</span>
        f0 = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
<span class="keyword">otherwise</span>
        error(<span class="string">'Order must be between 1 and 2'</span>);
<span class="keyword">end</span>

<span class="comment">% Plot IC of Distribution function, f, in Phase-Space:</span>
<span class="keyword">if</span> plot_figs == 1
   figure(1)
   surf(f0); grid <span class="string">on</span>; set(gca,<span class="string">'xDir'</span>,<span class="string">'reverse'</span>);
   xlabel(<span class="string">'x - Spatial Domain'</span>);
   ylabel(<span class="string">'v - Velocity Space'</span>);
   zlabel(<span class="string">'f - Probability'</span>);
<span class="keyword">end</span>
<span class="comment">% Compute Initial Macroscopic Momemts:</span>
    <span class="comment">%[rho,rhou,E] = macromoments1d(k,w,f0,v); %Just for testing</span>
    <span class="comment">%[~,~,~,p] = macroproperties1d(rho,rhou,E,nx,nv,theta);</span>
</pre><h2>Marching Scheme<a name="10"></a></h2><p>First we need to define how big is our time step. Due to the discrete ordinate method the problem is similar to evolve the same problem for every mesoscopic velocity.</p><pre class="codeinput">dt = dx*CFL/max(abs(v(:,1)));
dtdx = dt/dx;  <span class="comment">% precomputed to save someflops</span>

<span class="comment">% Time domain discretization</span>
time = 0:dt:tEnd;

<span class="comment">% By negleting any force field acting over our domian, the classic</span>
<span class="comment">% transport Boltzmann equation will resemble to a pure advection equation.</span>
<span class="comment">% Thus WENO, TVD, DG or CPR can be used easyly to compute evolution of the</span>
<span class="comment">% information inside the domain:</span>
tic
<span class="keyword">switch</span> method

    <span class="keyword">case</span>{1} <span class="comment">% Upwind 0(h)</span>
        <span class="comment">% Using discrete ordinate method (discrete and constant velocity</span>
        <span class="comment">% values in phase-space domain)</span>
        a = v(:,1);

        <span class="comment">% Load initial condition</span>
        f = f0;

        <span class="keyword">for</span> tsteps = time
            <span class="comment">% Plot and redraw figures every time step for visualization</span>
            <span class="keyword">if</span> plot_figs == 1
            <span class="comment">% Plot f distribution</span>
            figure(1)
            surf(f); grid <span class="string">on</span>; set(gca,<span class="string">'xDir'</span>,<span class="string">'reverse'</span>);
            xlabel(<span class="string">'x - Spatial Domain'</span>);
            ylabel(<span class="string">'v - Velocity Space'</span>);
            zlabel(<span class="string">'f - Probability'</span>);
            <span class="comment">% Plot Macroscopic variables</span>
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Density'</span>)
            subplot(2,3,2); plot(x,ux(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'velocity in x'</span>)
            subplot(2,3,3); plot(x,p(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Pressure'</span>)
            subplot(2,3,4); plot(x,z(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Fugacity'</span>)
            subplot(2,3,5); plot(x,t(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Temperature'</span>)
            subplot(2,3,6); plot(x,E(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Energy'</span>)
            <span class="keyword">end</span>
            <span class="comment">% Write Results</span>
            <span class="keyword">if</span> write_ans == 1 &amp;&amp; (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, <span class="string">'ZONE T = "time %0.4f"\n'</span>, tsteps);
                fprintf(file, <span class="string">'I = %d, J = 1, K = 1, F = POINT\n\n'</span>, nx);
                <span class="keyword">for</span> i = 1:nx
                    fprintf(file, <span class="string">'%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n'</span>, <span class="keyword">...</span>
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Compute equilibrium distribution for the current t_step</span>
            <span class="keyword">switch</span> fmodel
                <span class="keyword">case</span>{1} <span class="comment">% U.U.</span>
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                <span class="keyword">case</span>{2} <span class="comment">% E.S.</span>
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'Order must be between 1 and 2'</span>);
            <span class="keyword">end</span>

            <span class="comment">% initialize variables</span>
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);

            <span class="comment">% (this part can, and should be done in parallel!)</span>
            <span class="keyword">for</span> i = 1:nv
                <span class="comment">% load subcase</span>
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);

                <span class="comment">% Compute TVD Fluxes</span>
                [F_left,F_right] = Upwindflux1d(u,a(i,:));

                <span class="comment">% Compute next time step</span>
                u_next = u - dtdx*(F_right - F_left) <span class="keyword">...</span>
                    + (dt/r_time)*(u_eq-u);

                <span class="comment">% BC</span>
                u_next(1) = u_next(2);
                u_next(nx) = u_next(nx-1);

                <span class="comment">% UPDATE info</span>
                u = u_next;

                <span class="comment">% Going back to f</span>
                f(i,:) = u(:);
            <span class="keyword">end</span>

            <span class="comment">% Compute macroscopic moments</span>
            [rho,rhoux,E] = macromoments1d(k,w,f,v);

            <span class="comment">% UPDATE macroscopic properties</span>
            <span class="comment">% (here lies a paralellizing computing challenge)</span>
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);

            <span class="comment">% Apply DOM</span>
            [z,ux,t] = apply_DOM(z,ux,t,nv); <span class="comment">% Semi-classical variables</span>
            <span class="comment">%[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables</span>

            <span class="comment">% Update figures</span>
            drawnow
        <span class="keyword">end</span>

    <span class="keyword">case</span>{2} <span class="comment">% TVD 0(h^2)</span>
        <span class="comment">% Using discrete ordinate method (discrete and constant velocity</span>
        <span class="comment">% values in phase-space domain)</span>
        a = v(:,1);

        <span class="comment">% Load initial condition</span>
        f = f0;

        <span class="keyword">for</span> tsteps = time
            <span class="comment">% Plot and redraw figures every time step for visualization</span>
            <span class="keyword">if</span> plot_figs == 1
            <span class="comment">% Plot f distribution</span>
            figure(1)
            surf(f); grid <span class="string">on</span>; set(gca,<span class="string">'xDir'</span>,<span class="string">'reverse'</span>);
            xlabel(<span class="string">'x - Spatial Domain'</span>);
            ylabel(<span class="string">'v - Velocity Space'</span>);
            zlabel(<span class="string">'f - Probability'</span>);
            <span class="comment">% Plot Macroscopic variables</span>
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Density'</span>)
            subplot(2,3,2); plot(x,ux(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'velocity in x'</span>)
            subplot(2,3,3); plot(x,p(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Pressure'</span>)
            subplot(2,3,4); plot(x,z(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Fugacity'</span>)
            subplot(2,3,5); plot(x,t(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Temperature'</span>)
            subplot(2,3,6); plot(x,E(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Energy'</span>)
            <span class="keyword">end</span>
            <span class="comment">% Write Results</span>
            <span class="keyword">if</span> write_ans == 1 &amp;&amp; (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, <span class="string">'ZONE T = "time %0.4f"\n'</span>, tsteps);
                fprintf(file, <span class="string">'I = %d, J = 1, K = 1, F = POINT\n\n'</span>, nx);
                <span class="keyword">for</span> i = 1:nx
                    fprintf(file, <span class="string">'%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n'</span>, <span class="keyword">...</span>
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Compute equilibrium distribution for the current t_step</span>
            <span class="keyword">switch</span> fmodel
                <span class="keyword">case</span>{1} <span class="comment">% U.U.</span>
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                <span class="keyword">case</span>{2} <span class="comment">% E.S.</span>
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'Order must be between 1 and 2'</span>);
            <span class="keyword">end</span>

            <span class="comment">% initialize variables</span>
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);

            <span class="comment">% (this part can, and should be done in parallel!)</span>
            <span class="keyword">for</span> i = 1:nv
                <span class="comment">% load subcase</span>
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);

                <span class="comment">% Compute the smoothness factors, r(j), from data, u(j).</span>
                [r] = theta1d(u,a(i));

                <span class="comment">% Compute the Flux Limiter</span>
                [phi] = fluxlimiter1d(r,1); <span class="comment">% using limiter = 1</span>

                <span class="comment">% Compute TVD Fluxes</span>
                [F_left,F_right] = TVDflux1d(u,a(i),dtdx,phi);

                <span class="comment">% Compute next time step</span>
                u_next = u - dtdx*(F_right - F_left) <span class="keyword">...</span>
                    + (dt/r_time)*(u_eq-u);

                <span class="comment">% BC</span>
                u_next(1) = u_next(2);
                u_next(nx) = u_next(nx-1);

                <span class="comment">% UPDATE info</span>
                u = u_next;

                <span class="comment">% Going back to f</span>
                f(i,:) = u(:);
            <span class="keyword">end</span>

            <span class="comment">% Compute macroscopic moments</span>
            [rho,rhoux,E] = macromoments1d(k,w,f,v);

            <span class="comment">% UPDATE macroscopic properties</span>
            <span class="comment">% (here lies a paralellizing computing challenge)</span>
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);

            <span class="comment">% Apply DOM</span>
            [z,ux,t] = apply_DOM(z,ux,t,nv); <span class="comment">% Semi-classical variables</span>
            <span class="comment">%[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables</span>

            <span class="comment">% Update figures</span>
            drawnow
        <span class="keyword">end</span>

    <span class="keyword">case</span>{3,4} <span class="comment">% WENO(r = 2)3, 0(h^5) &amp; WENO(r = 3)5, 0(h^9)</span>
        <span class="comment">% Using discrete ordinate method (discrete and constant velocity</span>
        <span class="comment">% values in phase-space domain)</span>
        a = v(:,1);

        <span class="comment">% Load initial condition</span>
        f = f0;

        <span class="keyword">for</span> tsteps = time
            <span class="comment">% Plot and redraw figures every time step for visualization</span>
            <span class="keyword">if</span> plot_figs == 1
            <span class="comment">% Plot evolution of 'f' distribution function</span>
            figure(1)
            surf(f); grid <span class="string">on</span>; set(gca,<span class="string">'xDir'</span>,<span class="string">'reverse'</span>);
            xlabel(<span class="string">'x - Spatial Domain'</span>);
            ylabel(<span class="string">'v - Velocity Space'</span>);
            zlabel(<span class="string">'f - Probability'</span>);
            <span class="comment">% Plot Macroscopic variables</span>
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Density'</span>)
            subplot(2,3,2); plot(x,ux(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'velocity in x'</span>)
            subplot(2,3,3); plot(x,p(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Pressure'</span>)
            subplot(2,3,4); plot(x,z(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Fugacity'</span>)
            subplot(2,3,5); plot(x,t(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Temperature'</span>)
            subplot(2,3,6); plot(x,E(1,:),<span class="string">'.'</span>); axis <span class="string">tight</span>; title(<span class="string">'Energy'</span>)
            <span class="keyword">end</span>
            <span class="comment">% Write Results</span>
            <span class="keyword">if</span> write_ans == 1 &amp;&amp; (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, <span class="string">'ZONE T = "time %0.4f"\n'</span>, tsteps);
                fprintf(file, <span class="string">'I = %d, J = 1, K = 1, F = POINT\n\n'</span>, nx);
                <span class="keyword">for</span> i = 1:nx
                    fprintf(file, <span class="string">'%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n'</span>, <span class="keyword">...</span>
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Compute equilibrium distribution for the current t_step</span>
            <span class="keyword">switch</span> fmodel
                <span class="keyword">case</span>{1} <span class="comment">% U.U.</span>
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                <span class="keyword">case</span>{2} <span class="comment">% E.S.</span>
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                <span class="keyword">otherwise</span>
                    error(<span class="string">'Order must be between 1 and 2'</span>);
            <span class="keyword">end</span>

            <span class="comment">% initialize variables</span>
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);
            hn = zeros(1,nx-1);     <span class="comment">% Flux values at x_i+1/2 (-)</span>
            hp = zeros(1,nx-1);     <span class="comment">% Flux values at x_i-1/2 (+)</span>

            <span class="comment">% (this part can, and should be done in parallel!)</span>
            <span class="keyword">for</span> i = 1:nv
                <span class="comment">% Load subcase</span>
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);

                <span class="comment">% Scalar Flux Spliting</span>
                [vp,vn] = WENO_scalarfluxsplit(a(i)*u);

                <span class="comment">% Reconstruct Fluxes values at cells interfaces</span>
                <span class="keyword">switch</span> method
                    <span class="keyword">case</span>(3) <span class="comment">% WENO3</span>
                        <span class="keyword">for</span> j = 3:nx-2
                            xr = j-2:j+2; <span class="comment">% x-range of cells</span>
                            [hn(j),hp(j-1)] = WENO3_1d_flux(vp(xr),vn(xr));
                        <span class="keyword">end</span>
                        h = sum([hn;hp]);
                    <span class="keyword">case</span>{4} <span class="comment">% WENO5</span>
                        <span class="keyword">for</span> j = 4:nx-3
                            xr = j-3:j+3; <span class="comment">% x-range of cells</span>
                            [hn(j),hp(j-1)] = WENO5_1d_flux(vp(xr),vn(xr));
                        <span class="keyword">end</span>
                        h = sum([hn;hp]);
                <span class="keyword">end</span>

                <span class="comment">% Compute next time step</span>
                <span class="keyword">for</span> j = 4:nx-3
                    u_next(j) = u(j) - dtdx*(h(j) - h(j-1))<span class="keyword">...</span>
                        + (dt/r_time)*(u_eq(j)-u(j));
                <span class="keyword">end</span>

                <span class="comment">% BC</span>
                u_next = WENO3_1d_BCs(u_next,2,nx); <span class="comment">%2:Neumann BC</span>

                <span class="comment">% UPDATE info</span>
                u = u_next;

                <span class="comment">% Going back to f</span>
                f(i,:) = u(:);
            <span class="keyword">end</span>

            <span class="comment">% Compute macroscopic moments</span>
            [rho,rhoux,E] = macromoments1d(k,w,f,v);

            <span class="comment">% UPDATE macroscopic properties</span>
            <span class="comment">% (here lies a paralellizing computing challenge)</span>
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);

            <span class="comment">% Apply DOM</span>
            [z,ux,t] = apply_DOM(z,ux,t,nv); <span class="comment">% Semi-classical variables</span>
            <span class="comment">%[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables</span>

            <span class="comment">% Update figures</span>
            drawnow
        <span class="keyword">end</span>

    <span class="keyword">otherwise</span>
        error(<span class="string">'Order must be between 1 and 2'</span>);
<span class="keyword">end</span>
toc
</pre><pre class="codeoutput">Elapsed time is 33.369299 seconds.
</pre><h2>Close file with Results<a name="11"></a></h2><pre class="codeinput">fprintf(<span class="string">'Simulation has been completed succesfully!\n'</span>)
<span class="keyword">if</span> write_ans == 1
    fclose(file);
    fprintf(<span class="string">'All Results have been saved!\n'</span>)
<span class="keyword">end</span>

<span class="keyword">if</span> plot_figs ~= 1
    <span class="comment">% Plot Macroscopic variables</span>
    figure(2)
    subplot(2,3,1); plot(x,rho(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'Density'</span>)
    subplot(2,3,2); plot(x,ux(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'velocity in x'</span>)
    subplot(2,3,3); plot(x,p(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'Pressure'</span>)
    subplot(2,3,4); plot(x,z(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'Fugacity'</span>)
    subplot(2,3,5); plot(x,t(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'Temperature'</span>)
    subplot(2,3,6); plot(x,E(1,:),<span class="string">'o'</span>); axis <span class="string">tight</span>; title(<span class="string">'Energy'</span>)
<span class="keyword">end</span>
</pre><pre class="codeoutput">Simulation has been completed succesfully!
All Results have been saved!
</pre><img vspace="5" hspace="5" src="SBBGK_1d_01.png" alt=""> <p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
%% 1D Semi-classical Boltzmann-BGK Equation
% Numerical solution of the Boltzmann-BGK Equation to recover Euler macroscopic
% continuum solution. Coded by Manuel Diaz 2012.10.06
%
% Semi-classical Boltzmann-BGK Transport Equation:
%
% $$\frac{\partial f}{\partial t}+\vec F\cdot \nabla_p f + \vec v
% \cdot\nabla_{\vec x} f =\widehat{\Omega } (f) = - \frac{f-f^{eq}}{\tau}$$
%
clc;  clear all;  close all;

%% Simulation Parameters
    name	='SBBGK1d'; % Simulation Name
    CFL     = 10/100;   % CFL condition
    r_time  = 1/10000;  % Relaxation time
    tEnd  	= 0.05;     % End time
    theta 	= 0;        % {-1} BE, {0} MB, {1} FD.
    fmodel  = 1;        % {1} UU. model, {2} ES model.
    quad   	= 2;        % {1} NC , {2} GH
    method 	= 2;        % {1} Upwind, {2} TVD, {3} WENO3, {4} WENO5
    IC_case	= 1;        % IC: {1}Sod's, {2}LE, {3}RE, {4}DS, {5}SS, {6}Cavitation
  plot_figs = 0;        % 0: no, 1: yes please!
  write_ans = 1;        % 0: no, 1: yes please!
% Using DG
    P_deg	= 0;        % Polinomial Degree
    Pp      = P_deg+1;  % Polinomials Points
% Using RK integration time step
  RK_stages	= 4;        % Number of RK stages

%% Space Discretization
nx  = 100;                      % Desided number of points in our domain
x   = linspace(0,1,nx);         % Physical domain -x
dx  = max(x(2:end)-x(1:end-1)); % delta x

%% Define a ID name for results file
[ID, IDn] = ID_name(name,theta,nx,P_deg,RK_stages,r_time,IC_case);

%% Open a Files to store the Results
if write_ans == 1
    file = fopen(IDn,'w');
    % 'file' gets the handel for the file "case.plt".
    % 'w' specifies that it will be written.
    % similarly 'r' is for reading and 'a' for appending.
    fprintf(file, 'TITLE = "%s"\n',ID);
    fprintf(file, 'VARIABLES = "x" "density" "velocity" "energy" "pressure" "temperature" "fugacity"\n');
end

%% Initial Conditions in physical Space
% Load Macroscopic Fugacity [z], Velocity[u] and Temperature[t] 
    %[z0,u0,t0,p0,rho0,E0] = SSBGK_IC1d(x,IC_case);
    [z0,u0,t0,p0,rho0,E0] = SSBGK_IC1d(x,IC_case);

%% Microscopic Velocity Discretization (using Discrete Ordinate Method)
% that is to make coincide discrete values of microscopic velocities with
% values as the value points for using a quadrature method, so that we can
% integrate the velocity probability distribution to recover our
% macroscopics properties.
switch quad

    case{1} % Newton Cotes Quadrature:
    V  = [-40,40];  % range: a to b
    nv = 200;       % nodes desired (may not the actual value)
    [v,w,k] = cotes_xw(V(1),V(2),nv,5); % Using Netwon Cotes Degree 5
        
    case{2} % Gauss Hermite Quadrature:
    nv = 80;          % nodes desired (the actual value)
    [v,w] = GaussHermite(nv); % for integrating range: -inf to inf
    k = 1;            % quadrature constant.
    w = w.*exp(v.^2); % weighting function of the Gauss-Hermite quadrature
    
    otherwise
        error('Order must be between 1 and 2');
end
%% Velocity-Space Grid:
% The actual nv value will be computed using 'length' vector function:
    nv = length(v); 
% Using D.O.M.
    v = repmat(v,1,nx);     w = repmat(w,1,nx);

%% Applying Discrete Ordinate Method on ICs:
[z,ux,t] = apply_DOM(z0,u0,t0,nv);  % Semi-classical IC
[p,rho,E] = apply_DOM(p0,rho0,E0,nv); % Classical IC

% Compute distribution IC of our mesoscopic method by assuming the equilibrium 
% state of the macroscopic IC. Using the semiclassical Equilibrium
% distribuition function:
switch fmodel 
    case{1} % U.U.
        f0 = f_equilibrium_1d(z,ux,v,t,theta);
    case{2} % E.S.
        f0 = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
otherwise 
        error('Order must be between 1 and 2');
end
    
% Plot IC of Distribution function, f, in Phase-Space:
if plot_figs == 1
   figure(1)
   surf(f0); grid on; set(gca,'xDir','reverse');
   xlabel('x - Spatial Domain'); 
   ylabel('v - Velocity Space');
   zlabel('f - Probability');
end
% Compute Initial Macroscopic Momemts:
    %[rho,rhou,E] = macromoments1d(k,w,f0,v); %Just for testing
    %[~,~,~,p] = macroproperties1d(rho,rhou,E,nx,nv,theta);
    
%% Marching Scheme
% First we need to define how big is our time step. Due to the discrete
% ordinate method the problem is similar to evolve the same problem for
% every mesoscopic velocity.
dt = dx*CFL/max(abs(v(:,1))); 
dtdx = dt/dx;  % precomputed to save someflops

% Time domain discretization
time = 0:dt:tEnd;

% By negleting any force field acting over our domian, the classic
% transport Boltzmann equation will resemble to a pure advection equation.
% Thus WENO, TVD, DG or CPR can be used easyly to compute evolution of the
% information inside the domain: 
tic
switch method
    
    case{1} % Upwind 0(h)
        % Using discrete ordinate method (discrete and constant velocity
        % values in phase-space domain)
        a = v(:,1);
        
        % Load initial condition
        f = f0;
                        
        for tsteps = time
            % Plot and redraw figures every time step for visualization
            if plot_figs == 1
            % Plot f distribution
            figure(1)
            surf(f); grid on; set(gca,'xDir','reverse');
            xlabel('x - Spatial Domain');
            ylabel('v - Velocity Space');
            zlabel('f - Probability');
            % Plot Macroscopic variables
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),'.'); axis tight; title('Density')
            subplot(2,3,2); plot(x,ux(1,:),'.'); axis tight; title('velocity in x')
            subplot(2,3,3); plot(x,p(1,:),'.'); axis tight; title('Pressure')
            subplot(2,3,4); plot(x,z(1,:),'.'); axis tight; title('Fugacity')
            subplot(2,3,5); plot(x,t(1,:),'.'); axis tight; title('Temperature')
            subplot(2,3,6); plot(x,E(1,:),'.'); axis tight; title('Energy')
            end
            % Write Results
            if write_ans == 1 && (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, 'ZONE T = "time %0.4f"\n', tsteps);
                fprintf(file, 'I = %d, J = 1, K = 1, F = POINT\n\n', nx);
                for i = 1:nx
                    fprintf(file, '%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n', ...
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                end
            end
            
            % Compute equilibrium distribution for the current t_step
            switch fmodel
                case{1} % U.U.
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                case{2} % E.S.
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                otherwise
                    error('Order must be between 1 and 2');
            end
                        
            % initialize variables
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);
                              
            % (this part can, and should be done in parallel!)
            for i = 1:nv
                % load subcase
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);
                
                % Compute TVD Fluxes
                [F_left,F_right] = Upwindflux1d(u,a(i,:));

                % Compute next time step
                u_next = u - dtdx*(F_right - F_left) ...
                    + (dt/r_time)*(u_eq-u);

                % BC
                u_next(1) = u_next(2);
                u_next(nx) = u_next(nx-1);

                % UPDATE info
                u = u_next;
                
                % Going back to f
                f(i,:) = u(:);
            end
            
            % Compute macroscopic moments
            [rho,rhoux,E] = macromoments1d(k,w,f,v);
            
            % UPDATE macroscopic properties 
            % (here lies a paralellizing computing challenge)
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);
            
            % Apply DOM
            [z,ux,t] = apply_DOM(z,ux,t,nv); % Semi-classical variables
            %[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables
            
            % Update figures
            drawnow
        end
    
    case{2} % TVD 0(h^2)
        % Using discrete ordinate method (discrete and constant velocity
        % values in phase-space domain)
        a = v(:,1);
        
        % Load initial condition
        f = f0;
                        
        for tsteps = time
            % Plot and redraw figures every time step for visualization
            if plot_figs == 1
            % Plot f distribution
            figure(1)
            surf(f); grid on; set(gca,'xDir','reverse');
            xlabel('x - Spatial Domain');
            ylabel('v - Velocity Space');
            zlabel('f - Probability');
            % Plot Macroscopic variables
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),'.'); axis tight; title('Density')
            subplot(2,3,2); plot(x,ux(1,:),'.'); axis tight; title('velocity in x')
            subplot(2,3,3); plot(x,p(1,:),'.'); axis tight; title('Pressure')
            subplot(2,3,4); plot(x,z(1,:),'.'); axis tight; title('Fugacity')
            subplot(2,3,5); plot(x,t(1,:),'.'); axis tight; title('Temperature')
            subplot(2,3,6); plot(x,E(1,:),'.'); axis tight; title('Energy')
            end
            % Write Results
            if write_ans == 1 && (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, 'ZONE T = "time %0.4f"\n', tsteps);
                fprintf(file, 'I = %d, J = 1, K = 1, F = POINT\n\n', nx);
                for i = 1:nx
                    fprintf(file, '%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n', ...
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                end
            end
            
            % Compute equilibrium distribution for the current t_step
            switch fmodel
                case{1} % U.U.
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                case{2} % E.S.
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                otherwise
                    error('Order must be between 1 and 2');
            end
                        
            % initialize variables
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);
                              
            % (this part can, and should be done in parallel!)
            for i = 1:nv
                % load subcase
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);
                
                % Compute the smoothness factors, r(j), from data, u(j).
                [r] = theta1d(u,a(i));

                % Compute the Flux Limiter
                [phi] = fluxlimiter1d(r,1); % using limiter = 1

                % Compute TVD Fluxes
                [F_left,F_right] = TVDflux1d(u,a(i),dtdx,phi);

                % Compute next time step
                u_next = u - dtdx*(F_right - F_left) ...
                    + (dt/r_time)*(u_eq-u);

                % BC
                u_next(1) = u_next(2);
                u_next(nx) = u_next(nx-1);

                % UPDATE info
                u = u_next;
                
                % Going back to f
                f(i,:) = u(:);
            end
            
            % Compute macroscopic moments
            [rho,rhoux,E] = macromoments1d(k,w,f,v);
            
            % UPDATE macroscopic properties 
            % (here lies a paralellizing computing challenge)
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);
            
            % Apply DOM
            [z,ux,t] = apply_DOM(z,ux,t,nv); % Semi-classical variables
            %[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables
            
            % Update figures
            drawnow
        end
        
    case{3,4} % WENO(r = 2)3, 0(h^5) & WENO(r = 3)5, 0(h^9)
        % Using discrete ordinate method (discrete and constant velocity
        % values in phase-space domain)
        a = v(:,1);
        
        % Load initial condition
        f = f0;
                        
        for tsteps = time
            % Plot and redraw figures every time step for visualization
            if plot_figs == 1
            % Plot evolution of 'f' distribution function
            figure(1)
            surf(f); grid on; set(gca,'xDir','reverse');
            xlabel('x - Spatial Domain');
            ylabel('v - Velocity Space');
            zlabel('f - Probability');
            % Plot Macroscopic variables
            figure(2)
            subplot(2,3,1); plot(x,rho(1,:),'.'); axis tight; title('Density')
            subplot(2,3,2); plot(x,ux(1,:),'.'); axis tight; title('velocity in x')
            subplot(2,3,3); plot(x,p(1,:),'.'); axis tight; title('Pressure')
            subplot(2,3,4); plot(x,z(1,:),'.'); axis tight; title('Fugacity')
            subplot(2,3,5); plot(x,t(1,:),'.'); axis tight; title('Temperature')
            subplot(2,3,6); plot(x,E(1,:),'.'); axis tight; title('Energy')
            end
            % Write Results
            if write_ans == 1 && (mod(tsteps,5*dt) == 0 || tsteps == time(end))
                fprintf(file, 'ZONE T = "time %0.4f"\n', tsteps);
                fprintf(file, 'I = %d, J = 1, K = 1, F = POINT\n\n', nx);
                for i = 1:nx
                    fprintf(file, '%f\t%f\t%f\t%f\t%f\t%f\t%f\t\n', ...
                        x(1,i),rho(1,i),ux(1,i),E(1,i),p(1,i),t(1,i),z(1,i));
                end
            end
            
            % Compute equilibrium distribution for the current t_step
            switch fmodel
                case{1} % U.U.
                    f_eq = f_equilibrium_1d(z,ux,v,t,theta);
                case{2} % E.S.
                    f_eq = f_SE_equilibrium_1d(z,p,rho,ux,v,t,theta);
                otherwise
                    error('Order must be between 1 and 2');
            end
                        
            % initialize variables
            u_next = zeros(1,nx);
            u_eq = zeros(1,nx);
            u = zeros(1,nx);
            hn = zeros(1,nx-1);     % Flux values at x_i+1/2 (-)
            hp = zeros(1,nx-1);     % Flux values at x_i-1/2 (+)
                              
            % (this part can, and should be done in parallel!)
            for i = 1:nv
                % Load subcase
                u_eq(:) = f_eq(i,:);
                u(:) = f(i,:);
                
                % Scalar Flux Spliting
                [vp,vn] = WENO_scalarfluxsplit(a(i)*u);
                
                % Reconstruct Fluxes values at cells interfaces
                switch method
                    case(3) % WENO3
                        for j = 3:nx-2
                            xr = j-2:j+2; % x-range of cells
                            [hn(j),hp(j-1)] = WENO3_1d_flux(vp(xr),vn(xr));
                        end
                        h = sum([hn;hp]);
                    case{4} % WENO5
                        for j = 4:nx-3
                            xr = j-3:j+3; % x-range of cells
                            [hn(j),hp(j-1)] = WENO5_1d_flux(vp(xr),vn(xr));
                        end
                        h = sum([hn;hp]);
                end
                
                % Compute next time step
                for j = 4:nx-3
                    u_next(j) = u(j) - dtdx*(h(j) - h(j-1))...
                        + (dt/r_time)*(u_eq(j)-u(j));
                end
                
                % BC
                u_next = WENO3_1d_BCs(u_next,2,nx); %2:Neumann BC

                % UPDATE info
                u = u_next;
                
                % Going back to f
                f(i,:) = u(:);
            end
            
            % Compute macroscopic moments
            [rho,rhoux,E] = macromoments1d(k,w,f,v);
            
            % UPDATE macroscopic properties 
            % (here lies a paralellizing computing challenge)
            [z,ux,t,p] = macroproperties1d(rho,rhoux,E,nx,nv,theta);
            
            % Apply DOM
            [z,ux,t] = apply_DOM(z,ux,t,nv); % Semi-classical variables
            %[p,rho,E] = apply_DOM(p,rho,E,nv); % Classical variables
            
            % Update figures
            drawnow
        end
        
    otherwise
        error('Order must be between 1 and 2');
end
toc
%% Close file with Results
fprintf('Simulation has been completed succesfully!\n')
if write_ans == 1
    fclose(file);
    fprintf('All Results have been saved!\n')
end

if plot_figs ~= 1
    % Plot Macroscopic variables
    figure(2)
    subplot(2,3,1); plot(x,rho(1,:),'o'); axis tight; title('Density')
    subplot(2,3,2); plot(x,ux(1,:),'o'); axis tight; title('velocity in x')
    subplot(2,3,3); plot(x,p(1,:),'o'); axis tight; title('Pressure')
    subplot(2,3,4); plot(x,z(1,:),'o'); axis tight; title('Fugacity')
    subplot(2,3,5); plot(x,t(1,:),'o'); axis tight; title('Temperature')
    subplot(2,3,6); plot(x,E(1,:),'o'); axis tight; title('Energy')
end
##### SOURCE END #####
--></body></html>